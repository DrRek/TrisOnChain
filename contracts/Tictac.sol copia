pragma solidity ^0.4.24;

contract Tictac{
	
    event updateEvent();
	
	constructor() public {}
	
	struct Match{
        uint[3][3] table;
    	address playerUno;
    	address playerDue;
    	uint turno;
	}
	Match[] public pendingMatches;
	Match[] public runningMatches;
	
	function createMatch() public {
	    uint[3][3] memory emptyTable;
	    pendingMatches.push(Match(emptyTable, msg.sender, 0x0, 0));
	    emit updateEvent();
	}
	
	function joinMatch(uint id) public {
	    Match memory selectedMatch = pendingMatches[id];
	    
	    //delete pendingMatches[matchCreator];
	    pendingMatches[id] = pendingMatches[pendingMatches.length - 1];
	    pendingMatches.length--;
	    
	    selectedMatch.playerDue = msg.sender;
	    runningMatches.push(selectedMatch);
	    emit updateEvent();
	}
	
	function play(uint _x, uint _y, uint id) public{
		require(_x>=0 && _x<3 && _y>=0 && _y<3);
		
		Match memory playingMatch = runningMatches[id];
		
		if(msg.sender==playingMatch.playerUno && playingMatch.turno==0 && playingMatch.table[_x][_y]==0){
			playingMatch.table[_x][_y] = 1;
			playingMatch.turno = 1;
		}
		else if(msg.sender==playingMatch.playerDue && playingMatch.turno==1 && playingMatch.table[_x][_y]==0){
		    playingMatch.table[_x][_y] = 2;
		    playingMatch.turno = 0;
		}
		
		runningMatches[id] = playingMatch;
		
	    emit updateEvent();
	}

	function getPendingMatchesCount() public view returns(uint){
		return pendingMatches.length;
	}

	function getPendingMatchAtIndex(uint index) public view returns(uint, address){
		return (index, pendingMatches[index].playerUno);
	}
}